

# Detailed Documentation for the Inverse/Forward Prediction Script

## 1. Overview

This Python script provides an interactive tool that serves two primary purposes:

1. **Forward Prediction:**
   Given a set of 9 input parameters (which include various antenna design measurements and frequency), the script scales the input using a pre-trained scaler and then uses a pre-trained neural network model to predict the output (specifically the dB values for S(1,1) and S(2,1)).

2. **Inverse Prediction:**
   Given desired target output values (dB values), the script uses a numerical optimizer (with the L‑BFGS‑B method) to find the input parameters that best reproduce those target outputs. The optimizer minimizes the sum of squared errors between the model’s predicted output (after scaling) and the user-specified target dB values.

This tool is useful when you wish either to verify predictions (forward mode) or to “invert” the mapping (inverse mode) to determine which inputs will yield a desired antenna performance.

---

## 2. Import Statements and Global Dependencies

```python
import numpy as np
import tensorflow as tf
from tensorflow.keras.models import load_model
from scipy.optimize import minimize
import joblib
import re
```

### Explanation:
- **numpy (np):**
  Provides numerical operations and array handling.
- **tensorflow and keras (load_model):**
  TensorFlow is used to load the pre-trained deep learning model.
- **scipy.optimize (minimize):**
  Provides the optimization routine (L‑BFGS‑B) used in the inverse prediction.
- **joblib:**
  Used to load the pre-trained scaler (previously saved as `scaler.pkl`) that ensures input data is scaled the same way as during training.
- **re:**
  The regular expressions module; used to process and clean frequency strings.

---

## 3. Model and Scaler Loading

```python
model = load_model('/home/kayode-olalere/PycharmProjects/Project ANN/Codebase/Model/VER_3/v_1/best_model.h5',
                   compile=False)

scaler = joblib.load('/home/kayode-olalere/PycharmProjects/Project ANN/Codebase/Model/VER_3/v_1/scaler.pkl')
```

### Explanation:
- **Model Loading:**
  The pre-trained model is loaded from an HDF5 file. The `compile=False` flag is used because we are not planning to recompile the model (we are only doing inference and optimization).
- **Scaler Loading:**
  The scaler (a RobustScaler, for instance) is loaded using joblib. This scaler was used to normalize the features during training; applying the same scaler at inference ensures that the model’s inputs have the same scale as during training.

---

## 4. Frequency Parsing Functions

### 4.1. `parse_frequency`

```python
def parse_frequency(freq_str):
    """
    Convert a frequency string with an optional unit (MHz or GHz) into a numeric value in MHz.
    If no unit is provided, the number is assumed to be in MHz.
    """
    if isinstance(freq_str, str):
        freq_str = freq_str.strip()
        if "ghz" in freq_str.lower():
            numeric_part = re.sub(r'[^0-9\.]', '', freq_str)
            return float(numeric_part) * 1000
        elif "mhz" in freq_str.lower():
            numeric_part = re.sub(r'[^0-9\.]', '', freq_str)
            return float(numeric_part)
        else:
            try:
                return float(freq_str)
            except:
                return np.nan
    else:
        return float(freq_str)
```

### Explanation:
- **Purpose:**
  Cleans and converts a frequency value given as a string into a float representing the frequency in MHz.
- **Process:**
  - **String Cleaning:**
    Trims whitespace.
  - **Unit Detection:**
    Checks if the string contains “ghz” (ignoring case) and uses a regular expression (`re.sub`) to remove all characters except digits and the decimal point. If “ghz” is detected, multiplies the numeric value by 1000 (since 1 GHz = 1000 MHz).
    Similarly, if “mhz” is detected, it converts the numeric portion directly.
  - **Fallback:**
    If no unit is provided, it attempts to convert the string directly to a float. If conversion fails, returns `np.nan`.

### 4.2. `parse_forward_input`

```python
def parse_forward_input(input_str):
    """
    Parse a comma-separated input string for forward prediction.
    Expects 9 values for [l_s, l_2, l_1, s_2, s_1, w_s, w_2, w_1, freq].
    For the frequency field (9th value), allows an input like "3.600 GHz".
    """
    parts = input_str.split(",")
    if len(parts) != 9:
        raise ValueError("Exactly 9 values are required.")
    # Parse the first 8 values as floats
    values = [float(val) for val in parts[:8]]
    # For frequency, use parse_frequency to handle potential unit suffixes
    freq_val = parts[8].strip()
    try:
        freq = float(freq_val)
    except ValueError:
        freq = parse_frequency(freq_val)
    values.append(freq)
    return values
```

### Explanation:
- **Purpose:**
  Converts the user’s input string (for forward prediction) into a list of 9 numeric values.
- **Process:**
  - Splits the input by commas.
  - Checks if exactly 9 values are provided.
  - Converts the first 8 values to floats directly.
  - For the 9th value (frequency), uses `parse_frequency` to account for unit-suffixed strings (e.g., "3.600 GHz").

---

## 5. Forward and Inverse Prediction Functions

### 5.1. `forward_predict`

```python
def forward_predict(input_params):
    """
    Given 9 input parameters [l_s, l_2, l_1, s_2, s_1, w_s, w_2, w_1, freq] (freq in MHz),
    scale the input using the training scaler and predict the model's output.
    """
    input_arr = np.array(input_params, dtype='float32').reshape(1, -1)
    input_arr_scaled = scaler.transform(input_arr)
    pred = model.predict(input_arr_scaled)
    return pred.flatten()
```

### Explanation:
- **Purpose:**
  Computes the model’s prediction from a list of 9 input parameters.
- **Process:**
  - Converts the input list into a 2D NumPy array (batch size of 1).
  - Applies the scaler (loaded earlier) to ensure the inputs have the same distribution as the training data.
  - Uses the model to predict the output and returns a flat array of predictions.

### 5.2. `inverse_predict`

```python
def inverse_predict(target, initial_guess):
    """
    Given desired target output values (an array) and an initial guess for the 9 input parameters,
    use optimization (L-BFGS-B) to find input parameters that minimize the squared error between
    the forward prediction (with scaled input) and the target.

    Returns the optimal input parameters and the objective (error) value.
    """
    def objective(x):
        pred = forward_predict(x)
        error = np.sum((pred - target) ** 2)
        return error

    bounds = [
        (0, 25),    # l_s
        (0, 25),    # l_2
        (0, 25),    # l_1
        (0, 0.35),  # s_2
        (0, 0.35),  # s_1
        (0.6, 1.5), # w_s
        (0.6, 1.5), # w_2
        (0.6, 1.5), # w_1
        (800, 4000) # freq (in MHz)
    ]
    res = minimize(objective, x0=initial_guess, bounds=bounds, method='L-BFGS-B')
    return res.x, res.fun
```

### Explanation:
- **Purpose:**
  Solves the inverse problem: find the set of input parameters that yield a model prediction as close as possible to the desired target output (dB values).
- **Process:**
  - **Objective Function:**
    The nested function `objective(x)` computes the sum of squared errors between the model’s prediction (using the forward_predict function) and the target.
  - **Bounds:**
    Provides realistic limits for each input parameter based on domain knowledge.
  - **Optimization:**
    Uses SciPy’s `minimize` function with the L‑BFGS‑B method to search for input parameters that minimize the objective. Returns the optimized parameters and the final error.

---

## 6. Main Interactive Function

```python
def main():
    print("Welcome to the Advanced Prediction Script!")
    print("Choose a mode:")
    print("1. Forward Prediction: Provide input parameters to get the model's output.")
    print("2. Inverse Prediction: Provide desired target output values to find input parameters that produce them.")
    mode = input("Enter mode (forward/inverse): ").strip().lower()

    if mode == "forward":
        print("\nForward Prediction Mode:")
        print("Please enter 9 comma-separated values for [l_s, l_2, l_1, s_2, s_1, w_s, w_2, w_1, freq]")
        print("Example: 6.0,7.0,7.0,0.15,0.15,0.6,0.5,0.2,3.600 GHz")
        input_str = input("Input: ")
        try:
            input_params = parse_forward_input(input_str)
        except Exception as e:
            print(f"Error parsing input: {e}")
            return
        predicted = forward_predict(input_params)
        print(f"Model predicted output: {predicted}")

    elif mode == "inverse":
        print("\nInverse Prediction Mode:")
        print("Please enter the desired dB values for [dB(S(1,1)), dB(S(2,1))] (comma-separated, e.g., -2.528,-3.598)")
        target_str = input("Target: ")
        try:
            target = np.array([float(val) for val in target_str.split(",")])
            if target.shape[0] != 2:
                raise ValueError("Exactly 2 target values are required.")
        except Exception as e:
            print(f"Error parsing target values: {e}")
            return

        print("Now, please provide an initial guess for the 9 input parameters")
        print("Example: 6.0,7.0,7.0,0.15,0.15,0.6,0.5,0.2,3.300 GHz")
        guess_str = input("Initial guess (or press Enter to use default guess): ").strip()
        bounds = [
            (0, 25),    # l_s
            (0, 25),    # l_2
            (0, 25),    # l_1
            (0, 0.35),  # s_2
            (0, 0.35),  # s_1
            (0.6, 1.5), # w_s
            (0.6, 1.5), # w_2
            (0.6, 1.5), # w_1
            (800, 4000) # freq (in MHz)
        ]
        if guess_str == "":
            # Use the midpoint of each bound as the default guess.
            initial_guess = [(lb + ub) / 2 for lb, ub in bounds]
            print("Using default guess:", initial_guess)
        else:
            try:
                initial_guess = parse_forward_input(guess_str)
            except Exception as e:
                print(f"Error parsing initial guess: {e}")
                return

        solution, error_val = inverse_predict(target, initial_guess)
        print("\nOptimized Input Parameters (that should produce the desired output):")
        # Format the first 8 values to three decimals.
        formatted_values = [f"{val:.3f}" for val in solution[:-1]]
        # For frequency: if value >= 1000, display in GHz; otherwise, in MHz.
        if solution[-1] >= 1000:
            freq_in_ghz = solution[-1] / 1000.0
            formatted_freq = f"{freq_in_ghz:.3f} GHz"
        else:
            formatted_freq = f"{solution[-1]:.3f} MHz"
        formatted_solution = ", ".join(formatted_values + [formatted_freq])
        print(formatted_solution)
        print(f"Final objective (sum squared error): {error_val:.6f}")

    else:
        print("Invalid mode selected. Please run the script again and choose either 'forward' or 'inverse'.")


if __name__ == "__main__":
    main()
```

### Explanation:
- **Interactive Interface:**
  The `main()` function displays a menu asking the user to choose either forward or inverse prediction.

- **Forward Mode:**
  - **Input Prompt:**
    Requests 9 comma-separated values for the input parameters, with an example that shows the frequency can be specified with a unit (e.g., “3.600 GHz”).
  - **Parsing and Prediction:**
    The string is parsed using `parse_forward_input()`, then passed through `forward_predict()`, and the model’s output is printed.

- **Inverse Mode:**
  - **Target Input:**
    Prompts the user to input the desired target output values (dB values) for S(1,1) and S(2,1).
  - **Initial Guess:**
    The user can provide an initial guess. If no guess is provided (empty input), the script calculates a default guess using the midpoint of predefined bounds.
  - **Optimization:**
    Calls `inverse_predict()` with the target and initial guess. This function uses SciPy’s `minimize` (L‑BFGS‑B) to find the input parameters that minimize the squared error between the model’s prediction and the target.
  - **Output Formatting:**
    The optimized input parameters are formatted for clarity (first 8 values are shown with three decimals, and the frequency is displayed in GHz if above 1000 MHz).
  - **Final Objective:**
    The “final objective (sum squared error)” is printed, indicating how close the model’s output is to the target values (a lower value is better).

---

## 7. Summary

- **Modular Design:**
  The code is organized into functions for frequency parsing, input parsing, forward prediction, inverse prediction (via optimization), and the main interactive loop.

- **Preprocessing:**
  Special functions ensure that frequency inputs are correctly interpreted (with or without units) and that all inputs are scaled consistently with training.

- **Model Inference:**
  The pre-trained model is loaded along with a scaler; inputs are scaled, and predictions are made in forward mode.

- **Inverse Optimization:**
  The inverse mode leverages an optimization routine to “invert” the model’s mapping, finding input parameters that yield desired target outputs.

- **User Interaction:**
  Clear prompts and examples guide the user through both forward and inverse prediction, with optional default initial guesses to ease inverse prediction.

- **Visualization and Logging:**
  Although not directly used in the interactive script portion, earlier parts of the code (not shown in this snippet) include visualization functions and MLflow integration for tracking experiments.
